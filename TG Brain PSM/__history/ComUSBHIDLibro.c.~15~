///////////////////////////////////////////////////////////////////////////////
/*-------------------Cabezera Principal del Programa-------------------------*/
#INCLUDE <18F4550.H> //Indica el uC que se va usar
#DEVICE ADC=8 //activando el convertidor ana-dig
#USE DELAY(CLOCK=20M) // Frecuencia de trabajo
#FUSES HS,NOWDT, NOPROTECT, PUT, NOBROWNOUT, NOLVP // Velocidad del reloj, Desactivas el perro guardian, Espera de un tiempo de inicio,No reseteo por chequeo de la frecuencia ni fuente, No voltaje bajo de programaciÛn  

#byte port_b = 0xF81 //Identificador del Puerto B.

/*--------------------------------Comunicacion USB---------------------------*/

#define USB_HID_DEVICE TRUE //Tipo de comunicaci√≥n USB HID verdadera.
//Cambia a on EP1 para la transferencia de entrada IN bulk/interrupt.
#define USB_EP1_TX_ENABLE USB_ENABLE_INTERRUPT
#define USB_EP1_TX_SIZE 8
//Cambia a on EP1 para la transferencia de salida OUT bulk/interrupt.
#define USB_EP1_RX_ENABLE USB_ENABLE_INTERRUPT
#define USB_EP1_RX_SIZE 8
#include <pic18_usb.h> //Funciones de bajo nivel (hardware) que servir√°n en usb.c
#include <my_usb_desc_hid.h> //Descriptores del dispositivo.
#include <usb.c> //Librer√≠a para el manejo del USB.

///////////////////////////////////////////////////////////////////////////////

#define LED1 PIN_D0 //LED1para la espera de la conexi√≥n USB
#define LED2 PIN_D1 //LED2, se enciende cuando el USB est√° conectado.
int8 Salida[8]; //Variable de salida para envi√≥ de la informaci√≥n entrada anal√≥gica.
int8 Entrada[8]; //Variable para recibir el estado de los interruptores en LABVIEW.

#USE STANDARD_IO(A) //
#USE STANDARD_IO(B) //
LONG BITS; // variable almacena bits
FLOAT TEMP; //almacena la temperatura

void main()
{ //Funci√≥n principal.
        set_tris_b(0x00); //Define el Puerto B como salida.
        output_b(0x00); //Define el Puerto B en 0
        setup_adc(ADC_CLOCK_INTERNAL); //Fija el Clock interno para el ADC.
        set_adc_channel(0); //Fija el canal 0 para el ADC.
        output_high(LED1); //Activa LED1 indicando que se inici√≥ la conexi√≥n.
        output_low(LED2); //LED2 contin√∫a apagado.
        usb_init(); //Inicializa el LCD.
        usb_task(); //Monitorea el estado de la conexi√≥n conect√°ndose y desconect√°ndose autom√°ticamente.
        usb_wait_for_enumeration(); //Espera infinitamente hasta que el dispositivo sea.enumerado.
        output_high(LED2); //Apaga LED2 de espera.
        output_low(LED1); //Indica que el dispositivo se enumer√≥ y se estableci√≥ la comunicaci√≥n.
        
        while (TRUE)
        {
                setup_adc_ports(AN0);
                DELAY_MS(1);
                BITS=READ_ADC();
                TEMP=BITS*122.3990;
                usb_task(); //Monitorea el estado de la conexi√≥n conect√°ndose y desconect√°ndose autom√°ticamente.
                if (usb_enumerated())
                { //Si el dispositivo est√° enumerado‚Ä¶.?
                        Salida[0]=TEMP; //Lee el valor del ADC.
                        //Env√≠a al bus USB el paquete de datos.
                        usb_put_packet(1, Salida, 1, USB_DTS_TOGGLE);
                        if (usb_kbhit(1))
                        { //Si hay datos en el buffer del USB‚Ä¶.?
                                usb_get_packet(1, Entrada, 1); //Recibe el dato la variable entrada.
                                port_b= Entrada[0]; //Asigna al Puerto B el byte de Entrada.
                        }
                }
        } //Fin del lazo infinito.
} //Fin del main.
